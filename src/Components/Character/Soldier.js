import * as THREE from 'three'
/*
auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useState, useEffect } from 'react'
import { useFrame } from 'react-three-fiber'
import { useGLTF } from '@react-three/drei/useGLTF'
import soldierStatesStore from '../../Stores/SoldierStateStore'
import soldierPositionStore from '../../Stores/SoldierPositionStore'

export default function Soldier(props) {

  const soldierState = soldierStatesStore(state => state.soldierState);
//  const soldierStopPos = soldierPositionStore(state => state.soldierDestPosition);

  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/Soldier.glb');
  const [previousAnimation, setPreviousAnimation] = useState(0);

  const actions = useRef()
  const [mixer] = useState(() => new THREE.AnimationMixer());
  useFrame((state, delta) => mixer.update(delta))

  useEffect(() => {
    actions.current = {
      Idle: mixer.clipAction(animations[0], group.current),
      Run: mixer.clipAction(animations[1], group.current),
      TPose: mixer.clipAction(animations[2], group.current),
      Walk: mixer.clipAction(animations[3], group.current),
    }

   changeAction(soldierState);

   // return () => animations.forEach((clip) => mixer.uncacheClip(clip))
  }, [soldierState])


  function changeAction(status){    
    let prevAction = { action: mixer.clipAction(animations[previousAnimation], group.current)};
    let currentAct = { action: mixer.clipAction(animations[status], group.current) }
    currentAct.action.time = 0;
    currentAct.action.enabled = true;
    currentAct.action.setEffectiveTimeScale(1.0);
    currentAct.action.setEffectiveWeight(1.0);
    currentAct.action.crossFadeFrom( prevAction.action, 1, true )
    setPreviousAnimation(status);
    currentAct.action.play()
  }


  // const clock = new THREE.Clock();
  // const rotationMatrix = new THREE.Matrix4();
  // const targetQuaternion = new THREE.Quaternion();
  //   useFrame(()=>{
  //   const delta = clock.getDelta();

  //   if ( ! group.current.quaternion.equals( targetQuaternion ) ) {

  //       const step = 2 * delta;
  //       group.current.quaternion.rotateTowards( targetQuaternion, step );

  //   }
  // });


  // const soldierStopPos = soldierPositionStore(state => state.soldierDestPosition);
  // useEffect(() => {
  //   console.log(soldierStopPos)
  //   rotationMatrix.lookAt( soldierStopPos, group.current.position, group.current.up );
  //   targetQuaternion.setFromRotationMatrix( rotationMatrix );
  // }, [soldierStopPos])

  return (
    <group ref={group} {...props} dispose={null}>
      <group
        userData={{
          background_color: [0.05087608844041824, 0.05087608844041824, 0.05087608844041824],
          frames_per_second: 30,
        }}>
        <group rotation={[-Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]} userData={{ name: 'Character' }}>
          <primitive object={nodes.mixamorigHips} />
          <skinnedMesh
            material={materials.VanguardBodyMat}
            geometry={nodes.vanguard_Mesh.geometry}
            skeleton={nodes.vanguard_Mesh.skeleton}
            userData={{ name: 'vanguard_Mesh' }}
          />
          <skinnedMesh
            material={materials.Vanguard_VisorMat}
            geometry={nodes.vanguard_visor.geometry}
            skeleton={nodes.vanguard_visor.skeleton}
            userData={{ name: 'vanguard_visor' }}
          />
        </group>
      </group>
    </group>
  )
}


useGLTF.preload('/Soldier.glb')
